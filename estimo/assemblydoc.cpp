/**************************************************************************
 *  SharpEye Studio - Integrated Development Environment
 **************************************************************************
 *  University of Bristol
 *  Department of Electrical and Electronic Engineering
 *
 *  Copyright (C) 2008 George Vafiadis  <vafiadis@ieee.org>
 *
 **************************************************************************
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License version 2
 *  as published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 * 
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software
 **************************************************************************
 */

#include <QString>
#include <QSet>
#include <QList>
#include <QHash>
#include <QFile>
#include <QTextStream>
#include <fstream>
using namespace std;

#include "assemblydoc.h"
#include "asmcommand.h"
#include "patterntable.h"
#include "binaryword.h"
#include "entity.h"
#include "estimo_yacc.h"
#include "semanticerror.h"
#include "settings.h"

/// DEBUG Trick!
#define SLASH(s) /##s
#define COMMENT SLASH(/)
#define cout COMMENT
#define mycout cout

QVector<AsmCmd *> optimize(AssemblyDoc & doc, const QVector<AsmCmd *> & program);

// FIXME: to be removed
int AssemblyDoc::CMP_MAX = 8191 ;                    ///< The biggest number in compare commands
int AssemblyDoc::CMP_MIN = -8192;                    ///< The lowest number in compare commands
int AssemblyDoc::MIN_OFFSET = -32;                   ///< Minimum Value for the search window
int AssemblyDoc::MAX_OFFSET = 31;                    ///< Maximum Value for the search window


/// Checks if f represents an integer
bool is_integer(float f)
{ 
    int i = static_cast<int>(f); 
    return (f == static_cast<float>(i)); 
}

/// Check if pattern with name is integral pel or half/quarter pel
 bool AssemblyDoc::isPatternIntegralPel(QString name)
{
  const QVector<PatternTable::Point> & points = patterns[name];
  bool isInt = true;

  for(int i = 0; i < points.size(); ++i)
  {
	  if( is_integer(points[i].x) && is_integer(points[i].y) )
		  isInt = true;
	  else
	  { isInt = false; break; }
  }

  return isInt;
}


/// Constructor
AssemblyDoc::AssemblyDoc()
{
   init(); 
}


/// Initialize hash tables
void AssemblyDoc::init()
{
  curLabel = "";
  labNum = 1;
  patNum = 1;

  if( program.isEmpty() )
    for (int i = 0; i < program.size(); ++i)
       delete program.at(i);

  program.clear();
  pointMem.clear();
  checksIndex.clear();
  labels.clear();
  matchlabels.clear();
  patterns.clear();
}

/// Finalize the assembly document
void AssemblyDoc::endDoc()
{
 new HaltCmd(*this);
}

/// Set Point as Inttype or FloatType
void AssemblyDoc::setPointPelType(int index, bool fullpel)
{
	pointMem[index].isFullPel = fullpel;
}

/// Output assembly language file
void AssemblyDoc::outputAssembly(const QString &filename, const QString &binfile)
{
 QFile file(filename);

 if (!file.open(QIODevice::WriteOnly | QIODevice::Text))
         return;

 QTextStream out(&file);
 
 out << ".ASSEMBLY" << endl;
 out << "; Generated by SharpEye Studio!" << endl;
 out << "; WARNING! All changes made in this file will be lost!" << endl;
 out << endl;

 out << ".points" << endl;

 QHashIterator< QString, QVector<PatternTable::Point> > ipat(patterns);

   /// Iterate through all patterns
    while( ipat.hasNext() ) 
    {
      ipat.next();

      const QVector<PatternTable::Point> & pat = ipat.value();

      out << "\n.def " << ipat.key() << endl;

      QVectorIterator<PatternTable::Point> singlePoint(pat);

      while( singlePoint.hasNext() )
        { const PatternTable::Point & point = singlePoint.next();
          out << ".check " << point.x << ", " << point.y << endl;
        }	 
    }

 out << endl << endl;
 out << ".begin" << endl;

 /// Perform assembly optimization
 QVector <AsmCmd *> optProgram = assembly_optimization(*this, program);
 //QVector <AsmCmd *> optProgram = program;
 
 for(int i = 0; i < optProgram.size(); ++i)
    out << optProgram[i]->evalString() << endl;

 out << ".end" << endl;
 
 outputBinary(optProgram, binfile);

 file.close();
}

/// Output program in machine code
void AssemblyDoc::outputBinary(QVector <AsmCmd *> & optProgram, const QString &filename) const
{
 QFile file(filename);

 if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) return;

 QTextStream out(&file);

 for(int i = 0; i < CONF.program_memory_size; ++i)
  {
	if( i != 0 ) out << endl;

    if( i < optProgram.size() )
	{
      const BinaryWord & command = optProgram[i]->eval(0);
      out << command.getString();
	}
	else
		out << BinaryWord::getBits(0.0, CONF.instruction_bits, true);
  }

 file.close();
}

/// Dump Point memory to file
void AssemblyDoc::dumpMemory(const QString & filename) const
{
 QFile file(filename);

 if(!file.open(QIODevice::WriteOnly | QIODevice::Text)) return;

 QTextStream out(&file);

 for(int i = 0; i < CONF.point_memory_size; ++i)
  {
   if( i != 0 ) out << endl;
   if( i >= pointMem.size() )
   {
     out << BinaryWord::getBits(0.0, CONF.coordinate_bits, true) 
		 << BinaryWord::getBits(0.0, CONF.coordinate_bits, true); 
   }
   else
   {
    if( !isValidPoint(pointMem[i].x, pointMem[i].y) )
       throw SemanticError("Error: Point not Valid, out of range");
	  
    out  << BinaryWord::getBits(pointMem[i].x, CONF.coordinate_bits, pointMem[i].isFullPel)
		 << BinaryWord::getBits(pointMem[i].y,CONF.coordinate_bits, pointMem[i].isFullPel); 
   }	
  }

 file.close();
}

/// Check if the point offset is a valid range
bool AssemblyDoc::isValidPoint(float x, float y, bool fullpel)
{
 bool checkX;
 bool checkY;

 if( fullpel )
 {
   checkX = (x >= -126 && x <= 127);
   checkY = (y >= -126 && y <= 127);
 }
 else
 {
  checkX = (x >= -31 && x < 32 );
  checkY = (y >= -31 && y < 32 );
 }

 return checkX && checkY; 
}

/// Trace the hash table until you find the real match 
QString AssemblyDoc::traceLabel(QString label)
{
 while( matchlabels[label] != label )
 {
   label = matchlabels[label];
 }

 return label;
}

/// Return the address of the label in memory
int AssemblyDoc::getLabelAddress(QString label)
{
 return labels[traceLabel(label)];
}

/// Return a globally unique label name
QString AssemblyDoc::getUniqueLabelName(QString name)
{
  return QString("L%1").arg( labels[ traceLabel(name) ] );
}


/// Set the label for the next command
void AssemblyDoc::setLabel(QString lbl)
{ 
  if( ! lbl.isEmpty() )
     if( labels.contains(lbl) )
        throw SemanticError( QString("Error: %1 already defined label").arg(lbl) );


  if( curLabel != "" )
  {
   matchlabels[curLabel] = lbl;
  }

  cout << "####:" << curLabel.toStdString() << "  set new : " << lbl.toStdString() << "-> " << matchlabels[lbl].toStdString() << endl;

  curLabel = lbl; 
  labels[lbl] = program.size();
}

/// Return a unique label
QString AssemblyDoc::newLabel()
{
	QString newname = QString("Label%1").arg(labNum++);
	matchlabels[newname] = newname;
    return newname;
}

/// Return the label for the current command
QString AssemblyDoc::getNextLabel()
{ QString tmp = curLabel;
  curLabel = "";
  return tmp;
}

/// Return current program's size 
int AssemblyDoc::getProgramSize()
{
  return program.size();
}

/// Append a new Command
void AssemblyDoc::addNewCmd(AsmCmd *cmd)
{
  QString lbl = getNextLabel();

  cmd->setLabel(lbl);

  program.push_back(cmd);
}

/// Add input pattern and return a unique name
QString AssemblyDoc::addNewPattern(const QList<PatternTable::Point> & p)
{
   QVector<PatternTable::Point> points = QVector<PatternTable::Point>::fromList(p);

   QHashIterator< QString, QVector<PatternTable::Point> > i(patterns);

   /// Iterate through all patterns and check if the input pattern already defined
    while( i.hasNext() ) 
    {
      i.next();

     /// if the pattern already exists than just return the name 
     if( i.value() == points ) return i.key();
    }

  /// Otherwise insert the new pattern with a unique name
   QString nPat = newPatternName();

   patterns[nPat] = points;

   /// Append the new pattern to point memory
   QVectorIterator<PatternTable::Point> singlePoint(points);

   /// Keep where the new pattern starts in point memory
   checksIndex[nPat] = pointMem.size(); 
  
   /// Append all of the points in point memory
   while( singlePoint.hasNext() )
      pointMem.push_back( singlePoint.next() );

   return nPat;
 }

/// Return a new unique pattern name
QString AssemblyDoc::newPatternName() 
{ return QString("P%1").arg(patNum++); }

/// Return the number of points
int AssemblyDoc::getPatternSize(const QString &pname) const
{ return patterns[pname].size(); }
 
/// Return the start address of the pattern in point memory
int AssemblyDoc::getPatternStart(const QString &pName)
{ return checksIndex[pName]; } 

/// Return the pattern with the input name
const QVector<PatternTable::Point> AssemblyDoc::getPattern(const QString &patName) const
{ return patterns[patName]; }


/// Perform Assembly Optimization removing useless commands
QVector<AsmCmd *> assembly_optimization(AssemblyDoc & doc, const QVector<AsmCmd *> & program)
{
 QVector<AsmCmd *> opt;
 
 for(int i = 0; i < program.size(); ++i)
 {     
	 if( program[i]->isCheckJump() )
	 { 
	   CheckJumpCmd * jump     = static_cast<CheckJumpCmd *>(program[i]);
	   QString targetLabel     = jump->getTarget();
	   int     targetLocation  = doc.getLabelAddress(targetLabel);	 
	
	   while( program[targetLocation]->isJump() )
	   {       
		 JumpCmd * jumpjump = static_cast<JumpCmd *>(program[targetLocation]);

		 if( jumpjump->isUncond() )	   	   
		 {
           targetLabel    = jumpjump->getTarget();
		   targetLocation = doc.getLabelAddress(targetLabel);	  			   
		 }
		 else break;
	   }
	  
	   jump->setTarget(targetLabel);
	   opt.push_back(jump);   
	 } 
	 else if( program[i]->isJump() )       
	 {
       JumpCmd * jump            = static_cast<JumpCmd *>(program[i]);
       QString   targetLabel     = jump->getTarget();
	   int       targetLocation  = doc.getLabelAddress(targetLabel);	 
	
	   while( program[targetLocation]->isJump() )
	   {       
		 JumpCmd * jumpjump = static_cast<JumpCmd *>(program[targetLocation]);

		 if( jumpjump->isUncond() )	   	   
		 {
           targetLabel    = jumpjump->getTarget();
		   targetLocation = doc.getLabelAddress(targetLabel);	  			   
		 }
		 else break;
	   }
	  

	   jump->setTarget(targetLabel);	  
	   opt.push_back(jump);   
	 }  
	 else
	     opt.push_back(program[i]);
 }
 
 QVector<AsmCmd *> optim;

 for(int i = 0; i < opt.size(); ++i)
 {
	 cout << i << " LABELS: " << opt[i]->getHashLabel().toStdString()  <<"\t" << AsmCmd::describeType(opt[i]->getType()).toStdString();;
	 
	 if( opt[i]->isUncond() )
	 {
		 JumpCmd * jump = static_cast<JumpCmd *>(opt[i]);
		 QString initLabel = jump->getTarget();
    	 cout << "  " << "Hashkey = " << initLabel.toStdString() << "  " << "RealLabel = " <<  AsmCmd::getRealLabel(initLabel).toStdString() ;
		 cout << " Value = " <<  doc.getLabelAddress(initLabel);

		 /// If previous and current are jump instructions
		 if( !optim.isEmpty() && optim.last()->isUncond() )
		   {				   
			JumpCmd * prevjump = static_cast<JumpCmd *>(optim.last());
		    QString previnitLabel = prevjump->getTarget();
            int prevlocation = doc.getLabelAddress(previnitLabel);
		
			 /// If jumps to the following instruction ignore it
			 if( prevlocation == i + 1 )
				 optim.pop_back();
			
			 cout << endl << " prevlocation = " << prevlocation << ",  i " << i << endl;
             cout << endl << "Found double jumps!" << endl;
		     continue; 		 
		   }		 
		 else
		 {
	        int location = doc.getLabelAddress(initLabel);
	
			 cout << endl << " @@@@location = " << location << ",  i " << i << endl;
           
			 /// If jumps to the following instruction ignore it
			 if( location == i + 1 )
	           continue;         
		 } 
	 }
	 
	 /*
	 if( opt[i]->isCheckJump() )
	 {
      CheckJumpCmd * jump = static_cast<CheckJumpCmd *>(opt[i]);
	  QString initLabel = jump->getTarget();
      int location = doc.getLabelAddress(initLabel);	 

	  cout << "\n########CHECKJMP : " << location << "  " << i << endl;
	  if( location == i + 1 )
		  continue;

	 }
*/
	 cout << endl;
	 
     if( opt[i]->getHashLabel() != "" )	   
	   {
         QHash<QString, int> & labelTable = doc.getLabelHashTable(); 
	     labelTable[opt[i]->getHashLabel()] = optim.size();
		 cout << "CHANGE: labelTable[" << opt[i]->getHashLabel().toStdString() << "] = " << optim.size() << endl;
	   }

	 optim.push_back( opt[i] );	
 }


 /*
 for(int i = 0; i < optim.size(); ++i)
 {
	 cout << i << "\t" << optim[i]->evalString().toStdString() << endl;
 }
 
  cout << "**************************************************" << endl;

 */
  
 cout << "---------------------" << endl;


 {
QHash<QString, int> & labelTable = doc.getLabelHashTable();
 QHashIterator<QString, int> iter(labelTable);
 
 while (iter.hasNext()) 
 {
             iter.next();
			 QString thekey = AsmCmd::getRealLabel(iter.key());
			 cout  << thekey.toStdString() << ": (" << iter.key().toStdString() <<  ") = " << doc.getLabelAddress(iter.key()) << endl;
         } 

 cout << "---------------------" << endl;
 }

 return optim;
}
